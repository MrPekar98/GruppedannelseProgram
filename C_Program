#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <math.h>
#define GROUP_MAX_SIZE 6
#define DONE 7

/* Enumerations */
enum type_t {visionary = 1, idealist, conductor, troubleshooter};
typedef enum type_t personType_t;

/* Structs */
/* Belbin struct */
struct belbinTestData
{
    int plant;
    int monitorEvaluator;
    int specialist;
    int shaper;
    int implementer;
    int completerFinisher;
    int coordinator;
    int teamworker;
    int resourceInvestigator;
};

/* Structs */
/* Main struct: person struct */
struct person
{
    char name[30];
    personType_t type;

    /* Belbin struct declaration */
    struct belbinTestData belbin;
};
typedef struct person personData;

/* Group struct */
struct group
{
    /* Array of members */
    personData members[GROUP_MAX_SIZE];

    /* Average values */
    int averagePlant;
    int averageMonitorEvaluator;
    int averageSpecialist;
    int averageShaper;
    int averageImplementer;
    int averageCompleterFinisher;
    int averageCoordinator;
    int averageTeamworker;
    int averageResourceInvestigator;
};
typedef struct group group;

struct matrix
{
    int value;
    char rowColumn;
    char assignStage;
};
typedef struct matrix matrix;

/* Protocols */
int numberOfLines(FILE *f);
void personDataAssignment(FILE *file, personData *DataArray, int arraySize);
int groupSize(personData *groupMembers);
void assignFirstRound(personData *persons, group *groups, int amountOfGroups);
void averageBelbinTypeAssignment(group *theGroup);
void plantAverageAssign(group *theGroup, int groupSize);
void monitiorEvaluatorAverageAssign(group *theGroup, int groupSize);
void specialistAverageAssign(group *theGroup, int groupSize);
void shaperAverageAssign(group *theGroup, int groupSize);
void implementerAverageAssign(group *theGroup, int groupSize);
void completerFinisherAverageAssign(group *theGroup, int groupSize);
void coordinatorAverageAssign(group *theGroup, int groupSize);
void teamworkerAverageAssign(group *theGroup, int groupSize);
void resourceInvestigatorAverageAssign(group *theGroup, int groupSize);
int calValue(personData person, group g);
void matrixGroups(group *groups, personData *persons, int amountOfGroups, int amountOfPersons);
void hungarianAlgorithm(matrix *matrixArray[], int amountOfGroups, int *colCovered, int *rowCovered);
int findHighestValue(matrix **matrixArray, int row, int amountOfGroups);
void substractHighestValue(matrix **matrixArray, int amountOfGroups);
void Step1(matrix **matrixArray, int amountOfGroups);
int isZeroInRow(matrix **matrixArray, int amountOfGroups, int row);
int isZeroInColumn(matrix **matrixArray, int amountOfGroups, int column);
void Step2(matrix **matrixArray, int amountOfGroups);
int isDone(int *colCovered, int amountOfGroups);
void markColumnsWithStarredZero(matrix **matrixArray, int amountOfGroups, int *colCovered);
void Step3(matrix **matrixArray, int amountOfGroups, int *colCovered, int *rowCovered, int *stage);
void Step4(matrix **matrixArray, int amountOfGroups, int *colCovered, int *rowCovered, int *stage);
void erasePrimed(matrix **matrixArray, int amountOfGroups);
void uncoverLines(int *colCovered, int *rowCovered, int amountOfGroups);
void Step5(matrix **matrixArray, int amountOfGroups, int *colCovered, int *rowCovered, int *stage);

/* Main function */
int main()
{
    FILE *file = fopen("TestResultater.txt", "r");
    
    if (file == NULL)              /* File does not exist. */
    {
        printf("\nFile does not exist.\n");
    }

    const int amountOfStudents = numberOfLines(file);
    const int amountOfGroups = amountOfStudents / GROUP_MAX_SIZE;

    /* Data array: Containing all information about every student. */
    personData *persons = (personData *) malloc(amountOfStudents * sizeof(personData));

    if (persons == NULL)        /* Not enough memory. */
    {
        printf("\nNot enough space on memory.\n");
        exit(1);
    }

    personDataAssignment(file, persons, amountOfStudents);

    /* Array of groups. */
    group *groups = (group *) malloc(sizeof(group) * amountOfGroups);
    assert(groups != NULL);
    
    /* Algorithm */
    assignFirstRound(persons, groups, amountOfGroups);
    matrixGroups(groups, persons, amountOfGroups, amountOfStudents);
    
    fclose(file);
    free(persons);
    
    /* Test */

    return 0;
}

/* Returns number of lines in a file by scanning until each newline */
int numberOfLines(FILE *f)
{
    int i = 0;
    while(!feof(f))
    {
        fscanf(f, "%*[^\n] \n");
        i++;
    }
    
    fseek(f, 0, SEEK_SET);       /* Placing cursing back in the beginning. */
    return i;
}

/* Assigning data to main array containing all student. */
void personDataAssignment(FILE *file, personData *DataArray, int arraySize)
{
    int i;
    for (i = 0; i < arraySize; i++)
    {
        fscanf(file, "%s %u %d %d %d %d %d %d %d %d %d ", DataArray[i].name, &DataArray[i].type, &DataArray[i].belbin.plant, &DataArray[i].belbin.monitorEvaluator, &DataArray[i].belbin.specialist, &DataArray[i].belbin.shaper, &DataArray[i].belbin.implementer, &DataArray[i].belbin.completerFinisher, &DataArray[i].belbin.coordinator, &DataArray[i].belbin.teamworker, &DataArray[i].belbin.resourceInvestigator);
    }
}

/* Returns size of a group. */
int groupSize(personData *groupMembers)
{
    int i = 0;
    for (;i < GROUP_MAX_SIZE; i++)
    {
        if (groupMembers[i].type != 1 && groupMembers[i].type != 2 && groupMembers[i].type != 3 && groupMembers[i].type != 4)
        {
            break;
        }
    }

    return i;
}

/* Putting one person in each group as first round. */
void assignFirstRound(personData *persons, group *groups, int amountOfGroups)
{
    int i;
    for (i = 0; i < amountOfGroups; i++)
    {
        groups[i].members[0] = persons[i];
    }
}

/* Assigning average values for each Belbin type in a group. */
/* Enter the group array as argument. For example: averageBelbinTypeAssignment(&groups[1]);. */
void averageBelbinTypeAssignment(group *theGroup)
{
    plantAverageAssign(theGroup, groupSize((*theGroup).members));
    monitiorEvaluatorAverageAssign(theGroup, groupSize((*theGroup).members));
    specialistAverageAssign(theGroup, groupSize((*theGroup).members));
    shaperAverageAssign(theGroup, groupSize((*theGroup).members));
    implementerAverageAssign(theGroup, groupSize((*theGroup).members));
    completerFinisherAverageAssign(theGroup, groupSize((*theGroup).members));
    coordinatorAverageAssign(theGroup, groupSize((*theGroup).members));
    teamworkerAverageAssign(theGroup, groupSize((*theGroup).members));
    resourceInvestigatorAverageAssign(theGroup, groupSize((*theGroup).members));
}

/* Average value for plant type. */
void plantAverageAssign(group *theGroup, int groupSize)
{
    int i = 0, sum = 0;
    for (;i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.plant;
    }
    
    (*theGroup).averagePlant = sum / groupSize;
}

/* Average value for monitor evaluator type. */
void monitiorEvaluatorAverageAssign(group *theGroup, int groupSize)
{
    int i, sum = 0;
    for (i = 0; i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.monitorEvaluator;
    }
    
    (*theGroup).averageMonitorEvaluator = sum / groupSize;
}

/* Average value for specialist type. */
void specialistAverageAssign(group *theGroup, int groupSize)
{
    int i, sum = 0;
    for (i = 0; i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.specialist;
    }
    
    (*theGroup).averageSpecialist = sum / groupSize;
}

/* Average value for shaper type. */
void shaperAverageAssign(group *theGroup, int groupSize)
{
    int i, sum = 0;
    for (i = 0; i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.shaper;
    }
    
    (*theGroup).averageShaper = sum / groupSize;
}

/* Average value for implementer type. */
void implementerAverageAssign(group *theGroup, int groupSize)
{
    int i, sum = 0;
    for (i = 0; i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.implementer;
    }
    
    (*theGroup).averageImplementer= sum / groupSize;
}

/* Average value for completer finisher type. */
void completerFinisherAverageAssign(group *theGroup, int groupSize)
{
    int i, sum = 0;
    for (i = 0; i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.completerFinisher;
    }
    
    (*theGroup).averageCompleterFinisher= sum / groupSize;
}

/* Average value for coordinator type. */
void coordinatorAverageAssign(group *theGroup, int groupSize)
{
    int i, sum = 0;
    for (i = 0; i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.coordinator;
    }
    
    (*theGroup).averageCoordinator= sum / groupSize;
}

/* Average value for teamworker type. */
void teamworkerAverageAssign(group *theGroup, int groupSize)
{
    int i, sum = 0;
    for (i = 0; i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.teamworker;
    }
    
    (*theGroup).averageTeamworker= sum / groupSize;
}

/* Average value for resource investigator type. */
void resourceInvestigatorAverageAssign(group *theGroup, int groupSize)
{
    int i, sum = 0;
    for (i = 0; i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.resourceInvestigator;
    }
    
    (*theGroup).averageResourceInvestigator= sum / groupSize;
}

/* Calculates the combines differences of one person and one group */
int calValue(personData person, group g)
{
    int value = abs(person.belbin.plant - g.averagePlant) +
            abs(person.belbin.monitorEvaluator - g.averageMonitorEvaluator) +
            abs(person.belbin.specialist - g.averageSpecialist) +
            abs(person.belbin.shaper - g.averageShaper) +
            abs(person.belbin.implementer - g.averageImplementer) +
            abs(person.belbin.completerFinisher - g.averageCompleterFinisher) +
            abs(person.belbin.coordinator - g.averageCoordinator) +
            abs(person.belbin.teamworker - g.averageTeamworker) +
            abs(person.belbin.resourceInvestigator - g.averageResourceInvestigator);

    return value;
}

/* Main function for creating groups. Argument groups is an array. */
void matrixGroups(group *groups, personData *persons, int amountOfGroups, int amountOfPersons)
{
    int i;
    for (i = 0; i < amountOfGroups; i++)
    {
        averageBelbinTypeAssignment(&groups[i]);
    }

    /* Matrix */
    int x;
    matrix **matrixArray = (matrix **) malloc(sizeof(matrix) * amountOfGroups);
    for (x = 0; x < amountOfGroups; x++)
    {
        matrixArray[x] = (matrix *) malloc(sizeof(matrix) * amountOfGroups);
    }
    
    /* Arrays for marking rows and columns. */
    int colCovered[amountOfGroups];
    int rowCovered[amountOfGroups];
    uncoverLines(colCovered, rowCovered, amountOfGroups);
    
    int row, column, personCounter = 0;
    for (row = 0; row < amountOfGroups; row++)
    {
        for (column = 0; column < amountOfGroups; column++)
        {
            matrixArray[row][column].value = calValue(persons[row + amountOfGroups * personCounter], groups[column]);
        }
    }
    
    personCounter++;
    
    /* Hungarian algorithm. */
    hungarianAlgorithm(matrixArray, amountOfGroups, colCovered, rowCovered);
}

/* Hungarian algorithm */
void hungarianAlgorithm(matrix *matrixArray[], int amountOfGroups, int *colCovered, int *rowCovered)
{
    int stage = 1;
    
    switch (stage)         /* We need a loop to go through all steps. */
    {
        case 1:
            /* Step 1 */
            Step1(matrixArray, amountOfGroups);
            stage++;
            break;
            
        case 2:
            /* Step 2 */
            Step2(matrixArray, amountOfGroups);
            stage++;
            break;
            
        case 3:
            /* Step 3 */
            Step3(matrixArray, amountOfGroups, colCovered, rowCovered, &stage);
            break;
            
        case 4:
            Step4(matrixArray, amountOfGroups, colCovered, rowCovered, &stage);
            break;
            
        case 5:
            Step5(matrixArray, amountOfGroups, colCovered, rowCovered, &stage);
            break;
            
        case 6:
            break;
            
        case DONE:
            stage++;        /* Stage will be assigned 8 to end the while-loop. */
            break;
            
        default:
            break;
    }
}

/* Finds all values in a row with the highest value in the row. */
int findHighestValue(matrix **matrixArray, int row, int amountOfGroups)
{
    int j, highestValue = 0;
    for (j = 0; j < amountOfGroups; j++)
    {
        if (matrixArray[row][j].value > highestValue)
        {
            highestValue = matrixArray[row][j].value;
        }
    }
    
    return highestValue;
}

/* Subtract all values by highest value. */
void substractHighestValue(matrix **matrixArray, int amountOfGroups)
{
    int i, j, highestValue;
    for (i = 0; i < amountOfGroups; i++)
    {
        highestValue = findHighestValue(matrixArray, i, amountOfGroups);
        
        for (j = 0; j < amountOfGroups; j++)
        {
            matrixArray[i][j].value -= highestValue;
        }
    }
}

/* Step 1 */
void Step1(matrix **matrixArray, int amountOfGroups)
{
    substractHighestValue(matrixArray, amountOfGroups);
}

/* Boolean checking whether there is a zero in a row. */
int isZeroInRow(matrix **matrixArray, int amountOfGroups, int row)
{
    int j;
    for (j = 0; j < amountOfGroups; j++)
    {
        if (matrixArray[row][j].assignStage == 'S')
        {
            return 1;
        }
    }
    
    return 0;
}

/* Boolean checking whether there is a zero in a column. */
int isZeroInColumn(matrix **matrixArray, int amountOfGroups, int column)
{
    int i;
    for (i = 0; i < amountOfGroups; i++)
    {
        if (matrixArray[i][column].assignStage == 'S')
        {
            return 1;
        }
    }
    
    return 0;
}

/* Step 2  */
void Step2(matrix **matrixArray, int amountOfGroups)
{
    int i, j;
    for (i = 0; i < amountOfGroups; i++)
    {
        for (j = 0; j < amountOfGroups; j++)
        {
            if (matrixArray[i][j].value == 0 && !isZeroInRow(matrixArray, amountOfGroups, i) && !isZeroInColumn(matrixArray, amountOfGroups, j))
            {
                matrixArray[i][j].assignStage = 'S';
            }
        }
    }
}

/* Returns true if all columns are marked */
int isDone(int *colCovered, int amountOfGroups)
{
    int i;

    for(i = 0; i < amountOfGroups; i++)
    {
        if(!colCovered[i])
            return 0;
    }

    return 1;
}

/* Mark all columns with a starred zero */
void markColumnsWithStarredZero(matrix **matrixArray, int amountOfGroups, int *colCovered)
{
    int column, row;

    for(column = 0; column < amountOfGroups; column++)
    {
        for(row = 0; row < amountOfGroups; row++)
        {
            if(matrixArray[row][column].assignStage == 'S')
            {
                colCovered[column] = 1;
                break;
            }
        }
    }
}

/* Step 3 in the algorithm */
void Step3(matrix **matrixArray, int amountOfGroups, int *colCovered, int *rowCovered, int *stage)
{
    markColumnsWithStarredZero(matrixArray, amountOfGroups, colCovered);

    if (isDone(colCovered, amountOfGroups))
    {
        *stage = DONE;
    }
    
    else
    {
        *stage = 4;
    }
}

/* Step 4 */
void Step4(matrix **matrixArray, int amountOfGroups, int *colCovered, int *rowCovered, int *stage)
{
    int row, column;
    int largestUncoveredValue = -10000;

    /* Go through all elements in the matrix and find an uncovered zero */
    for (row = 0; row < amountOfGroups; row++)
    {
        if (!rowCovered[row])          /* If the row isnt covered, then go through the columns as well */
        {
            for (column = 0; column < amountOfGroups; column++)
            {
                if (matrixArray[row][column].value == 0)
                {
                    matrixArray[row][column].assignStage == 'P';
                    int i;
                    
                    /* Look through all elements in this row, and look for a starred zero */
                    for (i = 0; i < amountOfGroups; i++)
                    {
                        /* If there is a starred zero in the same row, then mark the row, and unmark the column with the starred zero */
                        if (matrixArray[row][column].assignStage == 'S')
                        {
                            rowCovered[row] = 1;
                            colCovered[i] = 0;
                            break;
                        }

                        /* If there is no starred zero in the same row, then go to step 5 */
                       *stage = 5;
                        return;
                    }

                    /* If there isnt any starred zero in this row, then go to step 5 */
                }
            }
        }
    }

    /* TODO: Save the largest value of the uncovered elements*/
    for (row = 0; row < amountOfGroups; row++)
    {
        if (!rowCovered[row])
        {
            for (column = 0; column < amountOfGroups; column++)
            {
                if (!colCovered[column])
                {
                    if (matrixArray[row][column].value > largestUncoveredValue)
                    {
                        largestUncoveredValue = matrixArray[row][column].value;
                    }
                }
            }
        }
    }

    *stage = 6;
}

/* Erases all primed */
void erasePrimed(matrix **matrixArray, int amountOfGroups)
{
    int row, column;
    for (row = 0; row < amountOfGroups; row++)
    {
        for (column = 0; column < amountOfGroups; column++)
        {
            if (matrixArray[row][column].assignStage == 'P')
            {
                matrixArray[row][column].assignStage = ' ';
            }
        }
    }
}

/* Uncoveres every line in matrix. */
void uncoverLines(int *colCovered, int *rowCovered, int amountOfGroups)
{
    int i;
    for (i = 0; i < amountOfGroups; i++)
    {
        colCovered[i] = 0;
        rowCovered[i] = 0;
    }
}

/* Step 5 */
void Step5(matrix **matrixArray, int amountOfGroups, int *colCovered, int *rowCovered, int *stage)
{
    int row, column;
    
    for (column = 0; column < amountOfGroups; column++)
    {
        /* If-statement executes when there is no starred ('S') zero in the column of a primed ('P') zero. */
        if (matrixArray[0][column].assignStage == 'P' && isZeroInColumn(matrixArray, amountOfGroups, column))
        {
            break;
        }
        
        else
        {
            for (row = 0; row < amountOfGroups; row++)
            {
                /* All starred zeros will be unstarred. */
                if (matrixArray[row][column].assignStage == 'S')
                {
                    matrixArray[row][column].assignStage = ' ';
                }
                
                /* All primed zeros will be starred. */
                else if (matrixArray[row][column].assignStage == 'P')
                {
                    matrixArray[row][column].assignStage = 'S';
                }
            }
        }
    }
    
    erasePrimed(matrixArray, amountOfGroups);
    uncoverLines(colCovered, rowCovered, amountOfGroups);
    *stage = 3;
}
