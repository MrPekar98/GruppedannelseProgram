#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#define GROUP_MAX_SIZE 6

/* Enumerations */
enum type_t {visionary = 1, idealist, conductor, troubleshooter};
typedef enum type_t personType_t;

/* Structs */
/* Belbin struct */
struct belbinTestData
{
    int plant;
    int monitorEvaluator;
    int specialist;
    int shaper;
    int implementer;
    int completerFinisher;
    int coordinator;
    int teamworker;
    int resourceInvestigator;
};

/* Structs */
/* Main struct: person struct */
struct person
{
    char name[30];
    personType_t type;

    /* Belbin struct declaration */
    struct belbinTestData belbin;
};
typedef struct person personData;

/* Group struct */
struct group
{
    /* Array of members */
    personData members[GROUP_MAX_SIZE];

    /* Average values */
    int averagePlant;
    int averageMonitorEvaluator;
    int averageSpecialist;
    int averageShaper;
    int averageImplementer;
    int averageCompleterFinisher;
    int averageCoordinator;
    int averageTeamworker;
    int averageResourceInvestigator;
};
typedef struct group group;

struct matrix
{
    int value;
    char rowColumn;
    char assignStage;
};
typedef struct matrix matrix;

/* Protocols */
int numberOfLines(FILE *f);
void personDataAssignment(FILE *file, personData *DataArray, int arraySize);
int groupSize(personData *groupMembers);
void assignFirstRound(personData *persons, group *groups, int amountOfGroups);
void averageBelbinTypeAssignment(group *theGroup);
void plantAverageAssign(group *theGroup, int groupSize);
void monitiorEvaluatorAverageAssign(group *theGroup, int groupSize);
void specialistAverageAssign(group *theGroup, int groupSize);
void shaperAverageAssign(group *theGroup, int groupSize);
void implementerAverageAssign(group *theGroup, int groupSize);
void completerFinisherAverageAssign(group *theGroup, int groupSize);
void coordinatorAverageAssign(group *theGroup, int groupSize);
void teamworkerAverageAssign(group *theGroup, int groupSize);
void resourceInvestigatorAverageAssign(group *theGroup, int groupSize);
int calValue(personData person, group g);
void matrixGroups(group *groups, personData *persons, int amountOfGroups, int amountOfPersons);

/* Main function */
int main()
{
    printf("Saved textfile must be located in the same directory as this program.\n\n");
    
    FILE *file = fopen("TestResultater.txt", "r");
    
    if (file == NULL)              /* File does not exist. */
    {
        printf("\nFile does not exist.\n");
    }

    const int amountOfStudents = numberOfLines(file);
    const int amountOfGroups = amountOfStudents / GROUP_MAX_SIZE;

    /* Data array: Containing all information about every student. */
    personData *persons = (personData *) malloc(amountOfStudents * sizeof(personData));

    if (persons == NULL)        /* Not enough memory. */
    {
        printf("\nNot enough space on memory.\n");
        exit(1);
    }

    personDataAssignment(file, persons, amountOfStudents);

    /* Array of groups. */
    group *groups = (group *) malloc(sizeof(group) * amountOfGroups);
    assert(groups != NULL);
    
    /* Algorithm */
    assignFirstRound(persons, groups, amountOfGroups);
    matrixGroups(groups, persons, amountOfGroups, amountOfStudents);
    
    fclose(file);
    free(persons);
    
    /* Test 
    int b;
    for (b = 0; b < 99; b++)
    {
        printf("%d %d %d %d %d\n", persons[b].belbin.plant, persons[b].belbin.monitorEvaluator, persons[b].belbin.coordinator, persons[b].belbin.shaper, persons[b].belbin.specialist);
    }*/

    return 0;
}

/* Returns number of lines in a file by scanning until each newline */
int numberOfLines(FILE *f)
{
    int i = 0;
    while(!feof(f))
    {
        fscanf(f, "%*[^\n] \n");
        i++;
    }
    
    fseek(f, 0, SEEK_SET);       /* Placing cursing back in the beginning. */
    return i;
}

/* Assigning data to main array containing all student. */
void personDataAssignment(FILE *file, personData *DataArray, int arraySize)
{
    int i;
    for (i = 0; i < arraySize; i++)
    {
        fscanf(file, "%s %u %d %d %d %d %d %d %d %d %d ", DataArray[i].name, &DataArray[i].type, &DataArray[i].belbin.plant, &DataArray[i].belbin.monitorEvaluator, &DataArray[i].belbin.specialist, &DataArray[i].belbin.shaper, &DataArray[i].belbin.implementer, &DataArray[i].belbin.completerFinisher, &DataArray[i].belbin.coordinator, &DataArray[i].belbin.teamworker, &DataArray[i].belbin.resourceInvestigator);
    }
}

/* Returns size of a group. */
int groupSize(personData *groupMembers)
{
    int i = 0;
    for (;i < GROUP_MAX_SIZE; i++)
    {
        if (groupMembers[i].type != 1 && groupMembers[i].type != 2 && groupMembers[i].type != 3 && groupMembers[i].type != 4)
        {
            break;
        }
    }

    return i;
}

/* Putting one person in each group as first round. */
void assignFirstRound(personData *persons, group *groups, int amountOfGroups)
{
    int i;
    for (i = 0; i < amountOfGroups; i++)
    {
        groups[i].members[0] = persons[i];
    }
}

/* Assigning average values for each Belbin type in a group. */
/* Enter the group array as argument. For example: averageBelbinTypeAssignment(&groups[1]);. */
void averageBelbinTypeAssignment(group *theGroup)
{
    plantAverageAssign(theGroup, groupSize((*theGroup).members));
    monitiorEvaluatorAverageAssign(theGroup, groupSize((*theGroup).members));
    specialistAverageAssign(theGroup, groupSize((*theGroup).members));
    shaperAverageAssign(theGroup, groupSize((*theGroup).members));
    implementerAverageAssign(theGroup, groupSize((*theGroup).members));
    completerFinisherAverageAssign(theGroup, groupSize((*theGroup).members));
    coordinatorAverageAssign(theGroup, groupSize((*theGroup).members));
    teamworkerAverageAssign(theGroup, groupSize((*theGroup).members));
    resourceInvestigatorAverageAssign(theGroup, groupSize((*theGroup).members));
}

/* Average value for plant type. */
void plantAverageAssign(group *theGroup, int groupSize)
{
    int i = 0, sum = 0;
    for (;i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.plant;
    }
    
    (*theGroup).averagePlant = sum / groupSize;
}

/* Average value for monitor evaluator type. */
void monitiorEvaluatorAverageAssign(group *theGroup, int groupSize)
{
    int i, sum = 0;
    for (i = 0; i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.monitorEvaluator;
    }
    
    (*theGroup).averageMonitorEvaluator = sum / groupSize;
}

/* Average value for specialist type. */
void specialistAverageAssign(group *theGroup, int groupSize)
{
    int i, sum = 0;
    for (i = 0; i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.specialist;
    }
    
    (*theGroup).averageSpecialist = sum / groupSize;
}

/* Average value for shaper type. */
void shaperAverageAssign(group *theGroup, int groupSize)
{
    int i, sum = 0;
    for (i = 0; i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.shaper;
    }
    
    (*theGroup).averageShaper = sum / groupSize;
}

/* Average value for implementer type. */
void implementerAverageAssign(group *theGroup, int groupSize)
{
    int i, sum = 0;
    for (i = 0; i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.implementer;
    }
    
    (*theGroup).averageImplementer= sum / groupSize;
}

/* Average value for completer finisher type. */
void completerFinisherAverageAssign(group *theGroup, int groupSize)
{
    int i, sum = 0;
    for (i = 0; i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.completerFinisher;
    }
    
    (*theGroup).averageCompleterFinisher= sum / groupSize;
}

/* Average value for coordinator type. */
void coordinatorAverageAssign(group *theGroup, int groupSize)
{
    int i, sum = 0;
    for (i = 0; i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.coordinator;
    }
    
    (*theGroup).averageCoordinator= sum / groupSize;
}

/* Average value for teamworker type. */
void teamworkerAverageAssign(group *theGroup, int groupSize)
{
    int i, sum = 0;
    for (i = 0; i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.teamworker;
    }
    
    (*theGroup).averageTeamworker= sum / groupSize;
}

/* Average value for resource investigator type. */
void resourceInvestigatorAverageAssign(group *theGroup, int groupSize)
{
    int i, sum = 0;
    for (i = 0; i < groupSize; i++)
    {
        sum += (*theGroup).members[i].belbin.resourceInvestigator;
    }
    
    (*theGroup).averageResourceInvestigator= sum / groupSize;
}

/* Calculates the combines differences of one person and one group */
int calValue(personData person, group g)
{
    int value = abs(person.belbin.plant - g.averagePlant) +
            abs(person.belbin.monitorEvaluator - g.averageMonitorEvaluator) +
            abs(person.belbin.specialist - g.averageSpecialist) +
            abs(person.belbin.shaper - g.averageShaper) +
            abs(person.belbin.implementer - g.averageImplementer) +
            abs(person.belbin.completerFinisher - g.averageCompleterFinisher) +
            abs(person.belbin.coordinator - g.averageCoordinator) +
            abs(person.belbin.teamworker - g.averageTeamworker) +
            abs(person.belbin.resourceInvestigator - g.averageResourceInvestigator);

    return value;
}

/* Main function for creating groups. Argument groups is an array. */
void matrixGroups(group *groups, personData *persons, int amountOfGroups, int amountOfPersons)
{
    int i;
    for (i = 0; i < amountOfGroups; i++)
    {
        averageBelbinTypeAssignment(&groups[i]);
    }
    
    /* Matrix */
    matrix matrixArray[amountOfGroups][amountOfGroups];
    
    int row, column, personCounter = 0;
    for (row = 0; row < amountOfGroups; row++)
    {
        for (column = 0; column < amountOfGroups; column++)
        {
            matrixArray[row][column].value = calValue(persons[row + amountOfGroups * personCounter], groups[column]);
        }
    }
    
    personCounter++;
    
    /* Hungarian algorithm. */
    
}
